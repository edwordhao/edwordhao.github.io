<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Markdown语法整理]]></title>
      <url>%2F2017%2F04%2F21%2FMarkdown%E8%AF%AD%E6%B3%95%E6%95%B4%E7%90%86%2F</url>
      <content type="text"><![CDATA[Markdown 常用语法一、粗体和斜体代码:1234*斜体* _斜体_**粗体*****加粗斜体***~~删除线~~ 显示效果 这是斜体xyz 这也是斜体xyz 这是粗体xyz 这是加粗斜体xyz 这是删除线 二、分级标题第一种写法 代码:12345这是一个一级标题==========================这是一个二级标题------------------------ 第二种写法代码:12345# 一级标题## 二级标题### 三级标题......###### 六级标题 ps: 由于用了[TOC]标记编辑器会把所有标题写到目录大纲中，在这里写的演示标题也会列进去，所以就不演示了。一级标题字号最大，依级递减。 三、超链接Markdown 支持两种形式的链接语法: 行内式和参考式两种形式,行内式一般使用的比较多 3.1行内式语法说明 []里面写链接的文字, ()里面写链接的地址, ()中的”” 中可以写链接指定的title 属性,title可加可不加. title属性的 效果是鼠标悬停在链接上会出现指定的title文字, 链接文字 这样的形式. 链接地址与链接标题之间有一个空格. 代码:12欢迎来到[我的博客](https://edwordhao.github.io)欢迎来到[我的博客](https://edwordhao.github.io &quot;我的个人博客&quot;) 显示效果 欢迎来到我的博客欢迎来到我的博客 3.2参考式参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。 语法说明 参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。 如果链接文字本身可以做为链接标记，你也可以写成[链接文字][][链接文字]：链接地址的形式，见代码的最后一行。 代码：123456我经常去的几个网站[mozilla][1]、[github][2]以及[自己的博客][3][mozilla][1]是一个查阅前端资料很不错的[网站][]。[1]:https://developer.mozilla.org/en-US/[2]:https://github.com/ &quot;github&quot;[3]:https://edwordhao.github.io/ &quot;梵居闹市&quot;[网站]:https://developer.mozilla.org/en-US/ 显示效果:我经常去的几个网站mozilla、github以及自己的博客mozilla是一个查阅前端资料很不错的网站。 3.3自动连接语法说明：Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： 代码：12&lt;http://mail.163.com/&gt;&lt;chaser_hh@163.com&gt; 显示效果http://mail.163.com/&#99;&#104;&#97;&#115;&#101;&#x72;&#95;&#x68;&#104;&#64;&#x31;&#54;&#51;&#x2e;&#99;&#111;&#109; 四、列表4.1无序列表使用 *，+，- 表示无序列表。 代码: 123- 无序列表项 一- 无序列表项 二- 无序列表项 三 显示效果: 无序列表项 一 无序列表项 二 无序列表项 三 4.2有序列表有序列表则使用数字接着一个英文句点。 代码: 1231. 有序列表项 一2. 有序列表项 二3. 有序列表项 三 显示效果 有序列表项 一 有序列表项 二 有序列表项 三 4.3包含引用的列表语法说明：如果要在列表项目内放进引用，那 &gt; 就需要缩进： 代码: 1234* 把大象放进冰箱的方法: &gt; 打开冰箱门。 &gt; 把大象放进去。 &gt; 关上冰箱门 显示效果: 把大象放进冰箱的方法: 打开冰箱门。把大象放进去。关上冰箱门 五、引用语法说明：引用需要在被引用的文本前加上&gt;符号。 代码：123&gt; 这是一个有两段文字的引用,&gt; 无意义的占行文字1.&gt; 无意义的占行文字2. 显示效果: 这是一个有两段文字的引用,无意义的占行文字1.无意义的占行文字2. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; : 代码: 123456&gt; 这是一个有两段文字的引用,无意义的占行文字1.无意义的占行文字2.&gt; 无意义的占行文字3.无意义的占行文字4. 显示效果: 这是一个有两段文字的引用,无意义的占行文字1.无意义的占行文字2. 无意义的占行文字3.无意义的占行文字4. 六、插入图像图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。 语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上。 6.1 行内式代码：12美丽花儿： ![美丽花儿](http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg &quot;美丽花儿&quot;) 显示效果: 美丽花儿： 6.2参考式代码： 123美丽花儿：![美丽花儿][flower][flower]:http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg &quot;美丽花儿&quot; 显示效果: 美丽花儿： 七、表格语法说明 不管是哪种方式，第一行为表头，第二行分隔表头和主体部分，第三行开始每一行为一个表格行。 列于列之间用管道符|隔开。原生方式的表格每一行的两边也要有管道符。 第二行还可以为不同的列指定对齐方向。默认为左对齐，在—-右边加上:就右对齐。在—-两边都加上: 则为居中对齐 代码: 简单方式写表格1234姓名|年龄|性别---|---:|:---:张山|18|男小红|16|女 原生方式写表格1234|姓名|年龄|性别||---|---|---||张山|18|男||小红|16|女| 显示效果: 简单方式写表格 姓名 年龄 性别 张山 18 男 小红 16 女 原生方式写表格 姓名 年龄 性别 张山 18 男 小红 16 女 八、LaTex公式 因在这个里面演示代码总出现问题.所以,下面附上一个链接 注: 公式详解见Cmd Markdown 编辑阅读器]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript中的运算符]]></title>
      <url>%2F2017%2F04%2F18%2F%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[运算符比较运算符比较运算符在逻辑语句中使用，以测定变量或值是否相等。 给定 x=5，下面的表格解释了比较运算符： 运算符 描述 例子 == 等于 x==8 为 false === 全等（值和类型） x===5 为 true；x===”5” 为 false != 不等于 x!=8 为 true &gt; 大于 x&gt;8 为 false &lt; 小于 x&lt;8 为 true &gt;= 大于或等于 x&gt;=8 为 false &lt;= 小于或等于 x&lt;=8 为 true 逻辑运算符逻辑运算符用于测定变量或值之间的逻辑。 给定 x=6 以及 y=3，下表解释了逻辑运算符： 123&amp;&amp; 且 (x &lt; 10 &amp;&amp; y &gt; 1) 为 true|| 或 (x==5 || y==5) 为 false! 非 !(x==y) 为 true 且 &amp;&amp; 对于布尔值，逻辑与是非常简单的，只要有一个false，就返回false； 对于不是布尔值的情况则： 如果第一个操作数是对象，则返回第二个数 如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才会返回该对象； 如果第两个操作数都是对象，则返回第二个数操作数 如果有一个操作数是null，则返回null 如果有一个操作数是NaN，则返回第NaN 如果第一个操作数是undefined，则返回undefined 逻辑运算符操作对象遵循从左到右的顺序来判断，逻辑与操作符（&amp;&amp;）先判断第一个数，如果第一个数的逻辑判断是true，则还需判断第二个数，结果输出第二个操作数；同理，如果第一个数为false，则不用考虑第二个数了，直接输出第一个数的逻辑判断结果，这和其他语言原理都是一样的。 或 || 对于布尔值，逻辑或是非常简单的，只要有一个true，就返回true； 对于不是布尔值的情况则： 如果第一个操作数是对象，则返第一个操作数 如果第一个操作数的求值结果为false，则返回第二个操作数 如果两个操作数都是对象，则返回第一个操作数 如果两个操作数是null，则返回null 如果两个操作数是NaN，则返回NaN 如果两个操作数是undefined，则返回undefined 原理同逻辑与(&amp;&amp;)，逻辑或(||)的判断是如果第一个操作数的逻辑判断为true，则直接输出第一个操作数，不用再考虑第二个操作数；如果第一个操作数的逻辑判断为false，则还得去判断第二个操作数的逻辑。 非 ! 如果一个操作数是一个对象，返回false; 如果一个操作数是一个空字符串，返回false; 如果一个操作数是一个非空字符串，返回false; 如果一个操作数是一个数值0，返回true; 如果一个操作数是任意的非零字符，返回false; 如果一个操作数是null，返回true; 如果一个操作数是NaN，返回true; 如果一个操作数是undefined，返回true; ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Math对象]]></title>
      <url>%2F2017%2F04%2F18%2FMath%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[Math对象Math对象用于执行常见的数学任务 Math对象的方法 方法 描述 abs(x) 返回 x 的绝对值 acos(x) 返回 x 的反余弦值 asin(x) 返回 x 的反正弦值。 atan(x) 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。 atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间）。 ceil(x) 对数进行上舍入。 cos(x) 返回数的余弦。 exp(x) 返回 e 的指数。 floor(x) 对数进行下舍入。 log(x) 返回数的自然对数（底为e）。 max(x,y) 返回 x 和 y 中的最高值。 min(x,y) 返回 x 和 y 中的最低值。 pow(x,y) 返回 x 的 y 次幂。 random() 返回 0 ~ 1 之间的随机数。 round(x) 把数四舍五入为最接近的整数。 sin(x) 返回数的正弦。 sqrt(x) 返回数的平方根。 tan(x) 返回角的正切。 toSource() 返回该对象的源代码。 valueOf() 返回 Math 对象的原始值。 Math对象的属性 属性 描述 E 返回算术常量 e，即自然对数的底数（约等于2.718）。 LN2 返回 2 的自然对数（约等于0.693）。 LN10 返回 10 的自然对数（约等于2.302）。 LOG2E 返回以 2 为底的 e 的对数（约等于 1.414）。 LOG10E 返回以 10 为底的 e 的对数（约等于0.434）。 PI 返回圆周率（约等于3.14159）。 SQRT1_2 返回返回 2 的平方根的倒数（约等于 0.707）。 SQRT2 返回 2 的平方根（约等于 1.414）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bfc详解]]></title>
      <url>%2F2017%2F04%2F12%2Fbfc%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[BFC详解人们经常会说到BFC,在网上面也有很多BFC的文章, 介绍了如何触发BFC,以及BFC的一些用处(如:清除浮动,防止margin重叠等). 虽然我们知道如何利用BFC去解决问题,但是当真正问道BFC是什么的时候,还是不能很励志气壮的解释清楚. 所以,最近我翻阅很多文档,现在在这里对BFC进行一个全面的汇总讲解 一. 什么是BFCBFC的定义BFC(Block Formatting Context) 直译为 “块级格式化上下文”. 是 W3C CSS 2.1 规范中的一个概念， 它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。 当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。 一个环境中的元素不会影响到其它环境中的布局。 比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。 这里有点类似一个BFC就是一个独立的行政单位的意思。也可以说BFC就是一个作用范围。 可以把它理解成是一个独立的容器，并且这个容器的里box的布局，与这个容器外的毫不相干。 BFC布局规则 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 哪些元素会生成BFC? 根元素 float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible 二. BFC的作用及原理 自适应两栏布局 123456789101112131415161718192021222324&lt;style&gt; .father &#123; width: 300px; position: relative; &#125; .aside &#123; width: 100px; height: 150px; float: left; background: red; &#125; .main &#123; height: 200px; background: pink; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="aside"&gt;&lt;/div&gt; &lt;div class="main"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; aside这个盒子是左浮动,脱离标准流,不占位置. 而且main这个盒子由于没有给宽度会继承父盒子father的宽度. 所以实现的效果是,aside这个盒子是压在main这个盒子的上面,左上角对齐. 根据BFC布局规则第3条： 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触。 当根据BFC布局规定的第四条 BFC的区域不会与float box重叠。 我们可以通过触发main生成BFC,来实现自适应两栏布局. 1234567891011121314151617181920212223242526272829.main &#123; overflow: hidden;&#125;``` 当触发main生成BFC后，这个新的BFC不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。2. 清除内部浮动```html&lt;style&gt; .father &#123; border: 5px solid #fcc; width: 300px; &#125; .child &#123; border: 5px solid #f66; width:100px; height: 100px; float: left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class="father"&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;div class="child"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; father这个盒子只有宽度,没有高度,child两个盒子,正常显示 根据BFC布局规则第六条 计算BFC的高度时，浮动元素也参与计算 为达到清除内部浮动，我们可以触发father生成BFC，那么father在计算高度时，father内部的浮动元素child也会参与计算 123.father &#123; overflow: hidden;&#125; 防止垂直 margin 重叠 1234567891011121314&lt;style&gt; p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;p&gt;Hehe&lt;/p&gt;&lt;/body&gt; 两个p之间的距离为100px，发送了margin重叠。 根据BFC布局规则第二条 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 我们可以在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。 12345678910111213141516171819&lt;style&gt; .wrap &#123; overflow: hidden; &#125; p &#123; color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;div class="wrap"&gt; &lt;p&gt;Hehe&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; 其实以上的几个例子都体现了BFC布局规则第五条 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 三. 总结因为BFC内部的元素和外部的元素绝对不会互相影响，因此，当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bash的介绍]]></title>
      <url>%2F2017%2F04%2F11%2Fbash%E7%9A%84%E4%BB%8B%E7%BB%8D%2F</url>
      <content type="text"><![CDATA[bashshell在计算机科学中，Shell俗称壳，用来区别于Kernel（核），是指“提供使用者使用界面”的软件（命令解析器）。它类似于DOS下的command和后来的cmd.exe。它接收用户命令，然后调用相应的应用程序。 核是操作系统的内核,壳是介于用户和操作系统内核之间的桥梁也就是说,用户可以通过壳来操作系统的内核 shell的分类 图形化shell 通过提供友好的可视化界面，调用相应应用程序 如: windows系列操作系统， Linux系统上的图形化应用程序GNOME、KDE等。 命令行shell 通过键盘输入特定命令的方式，调用相应的应用程序， 如: windows系统的cmd.exe、Windows PowerShell， Linux系统的Bourne shell ( sh)、Bourne Again shell ( bash)等。 bash在window系统下使用bash，需要一个软件，这个软件模拟集成了bash大部分命令。是shell的一种,几乎所有的linux的系统都会提供bash bash命令格式命令 [-options] [参数] 查看帮助：命令 --help bash常见的命令123456789101112131415161718192021222324cd 路径 (Change Directory) 切换目录pwd (Print Working Directory) 查看当前所处的路径ls (List) 查看当前目录下所有的文件信息 ls -a 查看所有的文件 ls -l 查看文件的详细信息 ls -al 查看文件的详细信息mkdir 文件夹名称 (Make Directory) 创建文件夹touch 文件名.后缀 创建文件rm 文件名 (remove) 删除指定的文件 rm -r 文件夹 删除指定的文件夹 rm -f 文件夹 强制删除指定的选项rmdir 文件名 (Remove Directory) 删除指定的空文件夹cp 源文件 目标文件 (copy) 将源文件复制到目标文件mv 源文件 目标文件 (move) 将源文件剪切到目标文件cat 文件 查看指定文件中的内容less 文件 分页查看指定文件中的内容echo 内容 将内容输出到屏幕&gt; / &gt;&gt; 重定向,可以将输出到屏幕的内容重定向到指定的文件中 &gt; 替换操作,会覆盖之前文件里面的内容 &gt;&gt; 追加操作,会在之前文件里面的内容后面追加上输入的内容| 管道符可以将多个命令连接使用，上一次（命令）的执行结果当成下一次（命令）的参数。grep 匹配内容，一般结合管道符使用clear 清空屏幕tab键 智能补全 vi编辑器如同Windows下的记事本，vi编辑器是Linux下的标配，通过它我们可以创建、编辑文件。它是一个随系统一起安装的文本编辑软件。 三种模式vi编辑器提供了3种模式，分别是普通模式、插入模式、命令模式，每种模式下用户所能进行的操作是不一样的。​ 普通模式 普通模式下面的命令 12345678910111213141516vi 文件路径 打开/创建文件i(insert) 进入编辑模式，当前光标处插入I(Insert) 在当前行之前插入o 进入编辑模式，当前行下面插入新行O 进入编辑模式，当前行上面插入新行a(append) 进入编辑模式，当前光标后插入A(Append) 进入编辑模式，光标移动到行尾ZZ 保存并退出yy 复制dd 删除当前行p 粘贴. 重复上一次的编辑操作u 辙销操作，可多次使用ctrl + r 反撤销ctrl + f 向前翻页trl + b 向后翻页 ​ 光标移动的命令 1234h 向左j 向下k 向上l 向右 2.插入模式 3.命令模式 ​ 命令模式下面的命令 123456789:w 文件名 保存文件:w filenme 另存为:q 退出编辑器:q! 不保存强制退出:w! 强制保存:wq 保存并且退出:set nu 显示行号:e 文件名 指定文件来编辑:e! 撤销更改，返回到上一次保存的状态 模式切换 普通模式 —&gt; 插入模式i / I / o / O / a / A 插入模式 —&gt; 普通模式esc / ctrl + [ 普通模式 —&gt; 命令模式: 命令模式 —&gt; 普通模式esc / ctlr + [ 插入模式 &amp; 命令模式 之间的转换必须先经过普通模式,再转换成命令模式 SSHSSH是一种网络协议，用于计算机之间的加密登录。 SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的是OpenSSH，它是自由软件，应用非常广泛。 如果要在Windows系统中使用SSH，会用到另一种软件PuTTY，我们后面用到的Git客户也集成了SSH 格式：ssh user@host user 代表真实存在的用户 host 代表要登录的远程计算机 常见有两种加密技术，分别是对称性加密和非对称性加密, SSH属于后者。 对称加密算法在加密和解密时使用的是同一个密钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥分别是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。 工作原理公钥和私钥是成对出现，可以通过ssh-keygen -t rsa来创建，既可以通过密钥来加密数据，也可以通过私钥来加密数据，如果是以公钥进行的数据加密，只能与之相对应的私钥才可以解密，相反如果以私钥进行的数据加密，则只能与之对应的公钥才可以将数据进行解密，这样就可以提高信息传递的安全性。 免密码登录（待定） 我们可以将本地机器上的公钥保存到特定的远程计算机上，这样当我们再次登录访问这台远程计算机时就可以实现免密码登录了。 1、ssh-keygen -t rsa会创建公钥和密钥（默认在用户目录/.ssh目录下） 2、ssh-copy-id user@host添加到对应远程主机的用户目录/.ssh目录下 3、也可以登录远程主机，进入到用户目录/.ssh目录下手动创建authorized_keys文件，并将自已的公钥粘入该文件。 版本控制工具 Version Control System (VCS)是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 这个系统可以自动帮我们备份文件的每一次更改，并且可以非常方便的恢复到任意的备份（版本）状态。 本地版本控制工具 (WebStorm VCS)​ 版本库存储在本地 集中式版本控制工具 (SVN TFS VSS)版本库存储在中央服务器,所有人都需要从服务器获取版本,修改之后要将版本提交到服务器 实际开发环境，一个项目通常是由多人协作共同完成的，如何让在不同终端上的开发者协同工作成了亟待解决的问题，集中式版本控制系统便应运而生了。它通过单一的集中管理的服务器，保存所有文件的修订版本，协同工作的开发者都通过客户端连到这台服务器，取出最新的文件或者提交更新。其代表为SVN 这种方式很好解决了多人协同开发的问题，但是也有一个弊端，如果集中管理的服务器出现故障，将会导致数据（版本）丢失的风险，另外协同开发者从集中服务器中更新数据时，严重依赖网络，如果网络不佳，也给开发带来诸多不便。 分布式版本控制工具 (Git)分布式版本控制系统，则不需要中央服务器，每个协同开发者都拥有一个完整的版本库，这么一来，任何协同开发者用的服务器发生故障，事后都可以用其它协同开发者本地仓库恢复。 由于版本库在本地计算机，也便不再受网络影响了。如果要将本地的修改，推送给其它协同开发者，还需要一台共享服务器，所有开发者通过这台共享服务器同步和更新数据 布式版本控制系统弥补了前面两种版本控制系统的缺陷，成为了版本控制的首选方案。其代表就是Git。 gitGit管理我们文件的4种状态， 分别为未追踪（untracked）、已提交（committed）、已修改（modified）和已暂存（staged） 由此引入 Git 项目的3个工作区域的概念：Git 仓库、工作目录以及暂存区域。 Git仓库目录 是Git用来保存项目的元数据和对象数据库的地方。 这是Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 工作目录 是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区域 是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中。有时候也被称作“索引”（Index），不过一般说法还是叫暂存区域。 基本的Git工作流程如下： 1、在工作目录中修改文件。 2、暂存文件，将文件的快照放入暂存区域。 3、提交文件，找到暂存区域的文件，将快照永久性存储到Git仓库目录。 git的常用命令12345678910111213git config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱&quot;上面两条为配置命令,每个电脑只需要执行一次git init 在当前文件夹下初始化一个git仓库, 每个项目只需要执行一次git status 查看当前工作目录下文件的状态git add 将文件添加到暂存区 -A 将所有的文件都添加到暂存区git commit -m &quot;备注信息&quot; 将文件从暂存区提交到版本库里面,并且生成新的版本git log 查看所有的提交历史git reset --hard 版本号 将代码恢复到指定的版本git chechout 文件名 将文件从暂存区恢复到工作目录 git的分支在我们的现实开发中，需求往往是五花八门的，同时开发个需求的情况十分常见，比如当你正在专注开发一个功能时，突然有一个紧急的BUG需要你来修复，这个时候我们当然是希望在能够保存当前任务进度，再去修改这个BUG，等这个BUG修复完成后再继续我们的任务。如何实现呢？ Git通过创建分支来解决实际开发中类似的问题。 12345678910111213141516git init --bare 初始化一个远程裸仓库git branch 分支名 查看 / 创建一个分支 git branch -a 查看全部分支git remote add 别名 远程仓库地址 给远程仓库地址设置一个别名 远程仓库管理 add show rename rmgit add file 跟踪文件git checkout --file (已跟踪)撤销更改git checkout 分支名 切换分支git checkout -b 分支名 切换并且创建一个新的分支git fetch 抓取远程数据git push 远程仓库地址 本地分支名:远程分支名 将本地数据推送到远程仓库git pull 远程仓库地址 获取远程数据并且合并git merge 合并分支git branch -d 分支名称 删除一个分支git clone 远程仓库地址 新创建目录名称 获取远程仓库中的代码 tip: 通过git clone命令获取到的项目，会有一个默认的远程地址origin,这个origin中的地址就是clone命令执行的时候的那个地址！]]></content>
    </entry>

    
  
  
</search>
